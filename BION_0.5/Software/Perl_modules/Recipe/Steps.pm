package Recipe::Steps;     #  -*- perl -*-

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DESCRIPTION <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# This package defines an interface between recipes seen by users and command 
# line tools and functions being run. This way users are freed from scripting 
# and developers can change command line and function arguments without 
# breaking recipes (many of which may be in use). 
#
# Recipes use mostly files but can also use streams. Recipes are read and 
# parsed by Recipe::IO::read_recipe. 
#
# REPRESENTATION 
#
# The interface is the %Step_map hash below. Recipes have step names and key-
# value parameters, as in this simple example from a recipe step,
#
#  <sequence-quality-trim>
#      title = 3-quality trim
#      trim-end = yes
#      window-length = 10
#      window-match = 10
#      minimum-quality = 96%
#  </sequence-quality-trim>
#
# The "sequence-quality-trim" string is key in %Step_map, and "title" and 
# the others are parameter sub-keys. The value of a sub-key is also a hash: 
# it gives value defaults, limits on ranges etc. The value hash has these 
# keys and meanings,
#
#    minlen   Minimum length of the option value
#    maxlen   Maximum length of the option value
#    defval   Default value
#      vals   A list of choices (list reference)
#       arg   Name of command line argument 
#      perm   File permission, r, w or x
#    needed   Flags mandatory options
#
# THE RUN HASH
#
# They look like this,
# 
#  "run" => {
#      "prl-cmd" => "seq_convert __INPATH__ --oformat fastq --ofile __OUTDIR__/__INFILE__.fq",
#      "out-fexp" => "__OUTDIR__/__OUTPRE__.*.fq",
#  }
#
# where keys are recognized by the Recipe::Run::run_recipe routine and values
# are command line and input/output file specifications, or function names 
# and arguments (incomplete). The following keys are recognized,
#
#       precmd   Single pre-command run first, e.g. format conversion
#   prl_precmd   Parallel pre-command run first
#          cmd   Single command
#      prl_cmd   Parallel command
#      postcmd   Single post-command
#  prl-postcmd   Parallel post-command
#      routine   A routine to run
#     out-fexp   A shell expression that should list output files generated by 
#                the method. This is used by the next method in a recipe to tell
#                which files to take as their input.
#    stat-fexp   A shell expression that should list the statistics files to be
#                written or appended to. Again, this is for the next method in 
#                a chain to use. If none is given, then the ones from the last 
#                method (run_recipe runs a loop). So giving this key a value 
#                resets which statistics files are used. 
#   use_recipe   Use sub-recipe as input instead of arguments
#
# SUPER-METHODS (unfinished)
# 
# Methods may consist of sub-methods. Simply give a list of their names as a 
# list value with the "steps" key.
#
# INPUTS AND OUTPUTS
#
# Methods take inputs from three sources, in decreasing precedence,
#
# 1. Explicit declaration with the run hash in-fexp key 
# 2. The outputs from the previous recipe step being run 
# 3. The command line
#
# Some methods take single input and create single output; others take multiple
# input and make single output; others again take single input and create 
# multiple outputs. Each method defines its output files which are then picked
# up by the next method in the recipe loop. Methods that write multiple outputs
# (e.g. demultiplexing of sequence) has a run hash field like 
#
#  "out-fexp" => "__OUTDIR__/__OUTPRE__.*.[FR]"
#
# which is a shell expression that will like lists the produced outputs. The 
# method that follows this will then look for these files. Many-to-one methods
# are simply getting the input files on the command line and writing a single 
# output. One-to-one methods are usually run with GNU parallel and its {} 
# placeholders used. 
#
# Tokens such as __OUTDIR__ are substituted with real values when a recipe is 
# run. Recognized tokens are,
#
# __INPATH__     Single input file path
# __INFILE__     Single input file base name (without directory)
# __INPATHS__    Multiple input files, for methods that take multiple inputs
# __STATPATH__   Statistics file 
# __OUTDIR__     Output directory
# __OUTPRE__     Output file prefix
#
# TO ADD A METHOD
# 
# First look through the methods below that work. Then pick the one that looks
# like the new method the most. Then find the command line arguments of the 
# software to be added. Give them whatever parameter names, but make their 
# names telling and easy to remember. Verbose is much better than cryptic or 
# ambiguous. Also remember recipe parameter names are very difficult to change
# without breaking recipes being used. So pick good names and try never to 
# change them. To test if the declaration works, make a dummy recipe file and
# run it with test data with the run_recipe program,
# 
# run_recipe recipe.file data-file(s) arguments
# 
# See the help screen for run_recipe.
#
# IF STUCK
#
# Contact Niels Larsen
#
# See http://genomics.dk under "Contact"
#
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

use strict;
use warnings FATAL => qw ( all );

use Tie::IxHash;

use vars qw ( @EXPORT_OK );
require Exporter;

@EXPORT_OK = qw (
                 %Step_map
                
);

use Common::Config;
use Common::Messages;

use Common::Obj;

use Recipe::Params;
use Recipe::Docs;
use Recipe::Messages;

use Registry::Check;

use base "Common::Obj";

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GLOBALS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

our ( %Step_map );

tie %Step_map, "Tie::IxHash";

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MAIN RECIPE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"recipe"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Recipe title", "needed" => 1 },
     "author" => { "needed" => 1 },
     "site" => {},
     "phone" => {},
     "email" => {},
     "skype" => {},
     "web" => {},
     "file" => {},
     "zip-outputs" => { "defval" => "no" },
     "reference-database" => {},
     "reference-sequence" => {},
     "reference-molecule" => {},
    );

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> SHELL COMMAND <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"shell-command"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Shell command" },
    );

# >>>>>>>>>>>>>>>>>>>>>>>>>>>> ALIGNMENT STEPS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"alignment-consensus"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Alignment consenses" },
     "quality-type" => { "arg" => "qualtype" },
     "consensus-method" => { "arg" => "method" },
     "minimum-sequences" => { "arg" => "minseqs" },
     "minimum-non-gaps" => { "arg" => "minres" },
     "minimum-base-quality" => { "arg" => "minqual" },
     "minimum-sequence-conservation" => { "arg" => "mincons" },
     "minimum-quality-conservation" => { "arg" => "minqcons" },
     "minimum-ambiguity-coverage" => { "arg" => "ambcover" },
     "maximum-columns-fail" => { "arg" => "maxfail" },
     "maximum-columns-quality-fail" => { "arg" => "maxqfail" },
     "minimum-length" => { "defval" => 15, "arg" => "minlen" },
     "trim-start" => { "arg" => "trimbeg" },
     "trim-end" => { "arg" => "trimend" },
     "run" => {
         "prl_cmd" => "ali_consensus __INPUT__ --ofasta __OUTPUT__ --ostats __STATS__",
         "out_suffix" => ".cons",
         "sum_routine" => "Ali::Consensus::write_stats_sum",
         "in_multi" => 1,
         "in_zipped" => 0,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

# >>>>>>>>>>>>>>>>>>>>>>>>>>>> SEQUENCE STEPS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"sequence-demultiplex"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence de-multiplexing" },
     "input-file-filter" => {}, 
     "bar-file" => { "arg" => "barfile", "needed" => 1 },
     "bar-spacing" => { "arg" => "bargap" },
     "bar-quality" => { "arg" => "barqual", "defval" => 99.9 },
     "quality-type" => { "arg" => "qualtype" },
     "primer-file" => { "arg" => "prifile" },
     "pairs-table" => { "arg" => "pairfile" },
     "pair-files1" => { "arg" => "files1" },
     "pair-files2" => { "arg" => "files2" },
     "include-singlets" => { "arg" => "singles", "defval" => "no" },
     "write-failed" => { "arg" => "failed", "defval" => "yes" },
     "merge-orientations" => { "arg" => "merge", "defval" => "yes" },
     "run" => {
         "cmd" => "seq_demul __INPUT__ --format fastq --outdir __OUTDIR__ --stats __STATS__",
         "out_suffix" => ".demul",
         "out_name" => "output",
         "in_multi" => 0,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-demultiplex-fluidigm"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Group-specific primer mapping" },
     "input-file-filter" => {},
     "primer-table" => { "arg" => "prifile" },
     "maximum-distance" => { "arg" => "pridist" },
     "write-forward" => { "arg" => "forward" },
     "write-reverse" => { "arg" => "reverse" },
     "write-pairs" => { "arg" => "pairs" },
     "run" => {
         "cmd" => "seq_demul_fluid __INPUT__ --outdir __OUTDIR__ --stats __STATS__ --outpre output --outsuf .demul",
         "out_suffix" => ".demul",
         "out_name" => "output",
         "in_multi" => 1,
         "out_multi" => 1,
         "out_dirs" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-dereplication"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence de-replication" },
     "run" => {
         "prl_cmd" => "seq_derep __INPUT__ --outfmt fastq --outfile __OUTPUT__ --stats __STATS__", 
         "prl_postcmd" => qq (rm __OUTPUT__.derep && mv __OUTPUT__.derep.fastq __OUTPUT__),
         "out_suffix" => ".uniq",
         "sum_routine" => "Seq::Storage::write_derep_stats_sum",
         "in_zipped" => 0,
         "in_multi" => 1,
         "out_multi" => 1,
     });

tie %{ $Step_map{"sequence-join-pairs"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Joining pair mates" },
     "minimum-similarity" => { "arg" => "minsim", "minval" => 50, "maxval" => 100, "defval" => 80 },
     "minimum-overlap" => { "arg" => "minovl", "defval" => 15 },
     "delete-inputs" => { "arg" => "delete", "defval" => "no" },
     "include-misses" => { "arg" => "misses", "defval" => "no" },
     "run" => {
         "cmd" => "seq_join_pairs __INPUT__ --outdir __OUTDIR__ --stats __STATS__",
         "out_suffix" => ".join",
         "in_multi" => 1,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-cleaning"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence cleaning" },
     "author" => { "defval" => "Someone's name" },
     "phone" => { "defval" => "Someone's phone number" },
     "email" => { "defval" => "Someone's e-mail" },
     "skype" => { "defval" => "Someone's skype id" },
     "quality-type" => { "arg" => "qualtype" },
     "input-sequence-format" => { "arg" => "seqfmt" },
     "steps" => [ qw ( sequence-filter sequence-filter-quality ),
                  qw ( sequence-trim-start sequence-trim-end ),
                  qw ( sequence-trim-quality-start sequence-trim-quality-end ),
                  qw ( sequence-clip-pattern-start sequence-clip-pattern-end ) ],
     "run" => {
         "prl_cmd" => "seq_clean __INPUT__ --oseqs __OUTPUT__ --stats __STATS__",
         "out_suffix" => ".clean",
         "sum_routine" => "Seq::Clean::write_stats_sum",
         "in_multi" => 1,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-clustering"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence clustering" },
     "alignment-suffix" => { "arg" => "oalsuf", "defval" => ".cluali" },
     "minimum-seed-similarity" => { "arg" => "minsim" },
     "minimum-cluster-size" => { "arg" => "minsize" },
     "maximum-ram" => { "arg" => "maxram" },
     "cluster-program" => { "arg" => "cluprog", "defval" => "uclust" },
     "cluster-arguments" => { "arg" => "cluargs" },
     "overlap-reclustering" => { "arg" => "cloops", "defval" => "no" },
     "overlap-alignment-size" => { "arg" => "cseqmin", "defval" => 3 },
     "overlap-off-sequences" => { "arg" => "crowmin", "defval" => "60%" },
     "overlap-off-percent" => { "arg" => "coffmin", "defval" => "60%" },
     "overlap-off-proportion" => { "arg" => "cbalmin", "defval" => "10%" },
     "overlap-orig-counts" => { "arg" => "corinum", "defval" => "yes" },
     "run" => {
         "prl_precmd" => "seq_convert __INPUT__ --oformat fasta --ofile __OUTPUT__.tmp.fa --silent --clobber",
         "prl_cmd" => "seq_cluster __OUTPUT__.tmp.fa --oalign __OUTPUT__ --tmpdir __TMPDIR__/cluster --stats __STATS__",
         "prl_postcmd" => qq (rm __OUTPUT__.tmp.fa),
         "out_suffix" => ".cluali",
         "sum_routine" => "Seq::Cluster::write_stats_sum",
         "in_multi" => 1,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-conversion"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence conversion" },
     "input-file-filter" => {},
     "input-sequence-format" => { "arg" => "seqfmt" },
     "output-sequence-format" => { "arg" => "oformat" },
     "run" => {
         "cmd" => "seq_convert __INPUT__ --oformat fastq --odir __OUTDIR__",
         "out_suffix" => ".fastq",
         "out_name" => "output",
         "in_multi" => 1,
         "in_zipped" => 0,
         "out_multi" => 1,
         "use_recipe" => 0,
         "use_stats" => 0,
     });

tie %{ $Step_map{"sequence-rarefaction"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence rarefaction" },
     "minimum-sequences" => { "arg" => "minseq" },
     "maximum-sequences" => { "arg" => "maxseq" },
     "run" => {
         "cmd" => "seq_rarefy __INPUT__ --outdir __OUTDIR__ --stats __STATS__",
         "out_suffix" => ".rare",
         "out_name" => "output",
         "in_multi" => 1,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-id-filter"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "ID filter" },
     "match-idfile" => {},
     "match-filter" => {},
     "non-match-idfile" => {},
     "non-match-filter" => {},
     "minimum-length" => { "arg" => "minlen", "defval" => 1 },
     "maximum-length" => { "arg" => "maxlen", "defval" => 2**30 },
     "run" => {
         "routine" => "Seq::Clean::filter_id_code",
     });

tie %{ $Step_map{"sequence-info-filter"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Info filter" },
     "match-filter" => {},
     "non-match-filter" => {},
     "run" => {
         "routine" => "Seq::Clean::filter_info_code",
     });

tie %{ $Step_map{"sequence-filter"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence filter" },
     "pattern-string" => { "arg" => "patstr" },
     "pattern-string-nomatch" => { "arg" => "patstr", "set" => "nomatch=1" },
     "forward" => { "arg" => "forward", "defval" => "yes" },
     "reverse" => { "arg" => "reverse", "defval" => "no" },
     "minimum-length" => { "arg" => "minlen" },
     "maximum-length" => { "arg" => "maxlen" },
     "minimum-gc-content" => { "arg" => "mingc" },
     "maximum-gc-content" => { "arg" => "maxgc" },
     "run" => {
         "routine" => "Seq::Clean::filter_seq_code",
     });

tie %{ $Step_map{"sequence-chimera-filter"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Chimera filter" },
     "word-length" => { "arg" => "wordlen", "defval" => 8, "minval" => 6, "maxval" => 12 },
     "step-length" => { "arg" => "steplen", "defval" => 4 },
     "minimum-parent-length" => { "arg" => "minfrag", "defval" => 80 },
     "minimum-score" => { "arg" => "minsco", "minval" => 0, "defval" => 30 },
     "dataset-name" => { "arg" => "dbname" },
     "dataset-file" => { "arg" => "dbfile" },
     "debug-output" => { "arg" => "debug", "defval" => "yes" },
     "read-buffer" => { "arg" => "seqbuf", "defval" => 2000 },
     "run" => {
         "cmd" => "seq_chimera __INPUT__ --stats __STATS__ --outdir __OUTDIR__",
         "out_suffix" => ".nochim",
         "in_multi" => 1,
         "out_multi" => 1,
         "sum_routine" => "Seq::Chimera::write_stats_sum",
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-mates-filter"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Mate-pairs filter" },
     "bar-file" => { "arg" => "barfile", "needed" => 1 },
     "maximum-distance" => { "arg" => "maxbeg", "minval" => 0, "defval" => 3 },
     "run" => {
         "cmd" => "seq_filter_mates __INPUT__ --outdir __OUTDIR__ --outpre __OUTPRE__",
         "out_suffix" => ".mates",
         "in_multi" => 1,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"sequence-filter-quality"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Quality filter" },
     "minimum-quality" => { "arg" => "minch", "defval" => "99%" },
     "maximum-quality" => { "arg" => "maxch", "defval" => "100%" },
     "minimum-strict" => { "arg" => "minpct", "defval" => "95%" },
     "maximum-strict" => { "arg" => "maxpct", "defval" => "100%" },
     "run" => {
         "routine" => "Seq::Clean::filter_qual_code",
     });

tie %{ $Step_map{"sequence-trim-start"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence trimming" },
     "sequence" => { "arg" => "seq", "needed" => 1 },
     "search-distance" => { "arg" => "dist", "defval" => 15 },
     "minimum-length" => { "arg" => "minlen", "defval" => 1 },
     "minimum-strict" => { "arg" => "minpct", "defval" => "95%" },
     "run" => {
         "routine" => "Seq::Clean::trim_seq_beg_code",
     });

tie %{ $Step_map{"sequence-trim-end"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence trimming" },
     "sequence" => { "arg" => "seq", "needed" => 1 },
     "search-distance" => { "arg" => "dist", "defval" => 15 },
     "minimum-length" => { "arg" => "minlen", "defval" => 1 },
     "minimum-strict" => { "arg" => "minpct", "defval" => "95%" },
     "run" => {
         "routine" => "Seq::Clean::trim_seq_end_code",
     });

tie %{ $Step_map{"sequence-trim-quality-start"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Quality trimming" },
     "window-length" => { "arg" => "winlen", "defval" => 10 },
     "window-match" => { "arg" => "winhit", "defval" => 9 },
     "minimum-quality" => { "arg" => "minch", "defval" => "99.0%" },
     "run" => {
         "routine" => "Seq::Clean::trim_qual_beg_code",
     });

tie %{ $Step_map{"sequence-trim-quality-end"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Quality trimming" },
     "window-length" => { "arg" => "winlen", "defval" => 10 },
     "window-match" => { "arg" => "winhit", "defval" => 9 },
     "minimum-quality" => { "arg" => "minch", "defval" => "99.0%" },
     "run" => {
         "routine" => "Seq::Clean::trim_qual_end_code",
     });

tie %{ $Step_map{"sequence-clip-pattern-start"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Pattern clipping" },
     "pattern-string" => { "arg" => "patstr", "needed" => 1 },
     "pattern-orient" => { "arg" => "seqori", "defval" => "forward" },
     "include-match" => { "arg" => "patinc", "defval" => "yes" },
     "search-distance" => { "arg" => "dist", "defval" => 15 },
     "run" => {
         "routine" => "Seq::Clean::clip_pat_beg_code",
     });
    
tie %{ $Step_map{"sequence-clip-pattern-end"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Pattern clipping" },
     "pattern-string" => { "arg" => "patstr", "needed" => 1 },
     "pattern-orient" => { "arg" => "seqori", "defval" => "forward" },
     "include-match" => { "arg" => "patinc", "defval" => "yes" },
     "search-distance" => { "arg" => "dist", "defval" => 15 },
     "run" => {
         "routine" => "Seq::Clean::clip_pat_end_code",
     });
    
tie %{ $Step_map{"sequence-remove-pattern"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Pattern clip + trimming" },
     "trim-start" => { "arg" => "begs" },
     "trim-end" => { "arg" => "ends" },
     "pattern-string" => { "arg" => "patstr", "needed" => 1 },
     "pattern-orient" => { "arg" => "seqori", "defval" => "forward" },
     "include-match" => { "arg" => "patinc", "defval" => "yes" },
     "search-distance" => { "arg" => "dist", "defval" => 15 },
     "run" => {
         "routine" => "Seq::Clean::clip_pat_code",
     });
    
tie %{ $Step_map{"sequence-extract"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sub-sequence extraction" },
     "run" => {
         "routine" => "Seq::Clean::extract_pats_code",
     });

# >>>>>>>>>>>>>>>>>>>>>>>>>> CONSENSUS PROFILE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"consensus-table"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Consensus table" },
     "pool-method" => { "arg" => "pmethod", "defval" => "exact" },
     "seq-minimum-reads" => { "arg" => "iminsiz" },
     "seq-minimum-length" => { "arg" => "iminlen", "defval" => 20 },
     "pool-minimum-length" => { "arg" => "pminlen", "defval" => 20 },
     "pool-minimum-non-gaps" => { "arg" => "pminres", "defval" => 5 },
     "pool-minimum-reads" => { "arg" => "pminsiz", "defval" => 1 },
     "pool-minimum-similarity" => { "arg" => "pminsim", "defval" => "100%" },
     "map-method" => { "arg" => "mmethod", "defval" => "exact" },
     "map-minimum-similarity" => { "arg" => "mminsim", "defval" => "95%" },
     "map-scale-reads" => { "arg" => "scale", "defval" => "no" },
     "column-ids" => { "arg" => "colids" },
     "column-id-pattern" => { "arg" => "colpat" },
     "column-id-file" => { "arg" => "colfile" },
     "zip-outputs" => { "defval" => "no" },
     "run" => {
         "cmd" => "seq_pool_map __INPUT__ --otable __OUTPUT__ --ostats __STATS__",
         "prl_postcmd" => "rm -f __INPUT__.derep __INPUT__.derep.table",
         "out_suffix" => ".conspool",
         "out_name" => "output",
         "in_multi" => 1,
         "in_zipped" => 0,
         "out_multi" => 0,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"consensus-table-clustering"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Consensus clustering" },
     "consensus-method" => { "arg" => "method", "defval" => "least_ambiguous" },
     "minimum-ambiguity-coverage" => { "arg" => "ambcover", "defval" => 0 },
     "minimum-similarity" => { "arg" => "minsim", "defval" => 100 },
     "minimum-non-gaps" => { "arg" => "minres", "defval" => 5 },
     "minimum-length" => { "arg" => "minlen", "defval" => 15 },
     "minimum-read-sum" => { "arg" => "minseqs", "defval" => 1 },
     "zip-outputs" => { "defval" => "no" },
     "run" => {
         "cmd" => "seq_map_cluster __INPUT__ --otable __OUTPUT__ --ofasta __OUTPUT__.fasta --ostats __STATS__",
         "out_suffix" => ".consclu",
         "out_name" => "output",
         "in_multi" => 0,
         "out_multi" => 0,
         "use_recipe" => 1,
     });

# >>>>>>>>>>>>>>>>>>>>>>>>>>>> PRIMERS AND BARCODES <<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"sequence-pattern"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence pattern" },
     "pattern-orient" => { "arg" => "seq_orient", "defval" => "forward" },
     "pattern-string" => { "arg" => "pat_string", "needed" => 1 },
     "pattern-string-nomatch" => { "arg" => "pat_string", "set" => "nommatch=1" },
     "get-elements" => { "arg" => "get_subpats", "split" => 1, "defval" => 1 },
     "get-orient" => { "arg" => "get_orient", "defval" => "forward" },
     "bar-label" => { "arg" => "bar_label", "defval" => "F-tag" },
    );
    
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> ORGANISM STEPS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"sequence-similarities-simrank"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence similarities" },
     "dataset-name" => { "arg" => "dbname" },
     "dataset-file" => { "arg" => "dbfile" },
     "quality-type" => { "arg" => "qualtype" },
     "minimum-base-quality" => { "arg" => "minqual" },
     "match-agct-only" => { "arg" => "wconly", "defval" => "yes" },
     "match-minimum" => { "arg" => "minsim", "defval" => 60 },
     "match-top-range" => { "arg" => "topsim", "defval" => 3 },
     "match-word-length" => { "arg" => "wordlen", "defval" => 8 },
     "match-step-length" => { "arg" => "steplen", "defval" => 1 },
     "match-forward" => { "arg" => "forward", "defval" => "yes" },
     "match-reverse" => { "arg" => "reverse", "defval" => "no" },
     "run-parallel-cores" => { "arg" => "parallel" },
     "zip-outputs" => { "defval" => "no" },
     "run" => {
         "cmd" => "org_profile_sims __INPUT__ --outdir __OUTDIR__ --outpre __OUTPRE__ --stats __STATS__",
         "out_suffix" => ".sims",
         "dir_routine" => "Taxonomy::Profile::write_stats_sims_sum",
         "out_name" => "output",
         "use_recipe" => 1,
         "in_multi" => 1,
         "out_multi" => 1,
     });

tie %{ $Step_map{"organism-taxonomy-profiler"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Organism taxonomy profiler" },
     "dataset-name" => { "arg" => "dbname" },
     "minimum-oligo-count" => { "arg" => "minoli" },
     "minimum-group-percent" => { "arg" => "mingrp" },
     "maximum-ambiguity-level" => { "arg" => "maxamb", "defval" => 1 },
     "match-minimum" => { "arg" => "minsim", "defval" => 60 },
     "match-use-range" => { "arg" => "topsim", "defval" => 1 },
     "match-weight" => { "arg" => "simwgt", "defval" => 1 },
     "zip-outputs" => { "defval" => "no" },
     "run" => {
         "cmd" => "org_profile_mapper --sims '__INPUT__' --seqs '__INPUT__.seqs' --outdir __OUTDIR__ --outpre __OUTPRE__ --stats __STATS__",
         "out_suffix" => ".profile",
         "dir_routine" => "Taxonomy::Profile::write_stats_profile_sum",
         "out_name" => "output",
         "in_multi" => 1,
         "out_multi" => 1,
         "use_recipe" => 1,
     });

tie %{ $Step_map{"organism-profile-format"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Profile filter", "arg" => "title" },
     "normalized-column-total" => { "arg" => "colsum" },
     "show-level" => { "arg" => "level" },
     "taxonomy-minimum-score" => { "arg" => "minval", "defval" => 1 },
     "taxonomy-minimum-sum" => { "arg" => "minsum", "defval" => 1 },
     "taxonomy-text-filter" => { "arg" => "taxexp" },
     "decimal-places" => { "arg" => "places", "defval" => 0 },
     "bar-file" => { "arg" => "barfile" },
     "table-title-regex" => { "arg" => "colexp" },
     "zip-outputs" => { "defval" => "no" },
     "run" => {
         "cmd" => "org_profile_format __INPUT__ --oname __OUTPUT__ --stats __STATS__",
         "out_suffix" => ".subtax",
         "dir_routine" => "Taxonomy::Profile::write_stats_format_dirs",
         "in_multi" => 0,
         "out_multi" => 1,
         "out_name" => "output",
         "use_recipe" => 1,
     });

tie %{ $Step_map{"organism-profile-merge"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Profile merge" },
     "zip-outputs" => { "defval" => "no" },
     "run" => {
         "cmd" => "org_profile_merge __INPUT__ --otable __OUTPUT__",
         "use_recipe" => 1,
         "in_multi" => 1,
         "out_multi" => 0,
         "out_suffix" => ".merged",
         "out_name" => "output",
     });

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DATA <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

tie %{ $Step_map{"sequence-region"} }, "Tie::IxHash",
    (
     "title" => { "defval" => "Sequence regions" },
     "forward-primer" => {},
     "reverse-primer" => {},
     "from-position" => {},
     "to-position" => { },
     "include-primer" => {},
     "minimum-length" => {},
    );

# >>>>>>>>>>>>>>>>>>>>>>>>>>> VALIDATION STEPS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# These routines adds defaults and checks the above steps for mistakes. This
# module should only load if the map above is okay and usable. If not, there 
# will be fatal errors made by this routines,

&Recipe::Steps::add_def_values( \%Step_map );
&Recipe::Steps::add_def_params( \%Step_map );

&Recipe::Steps::check_mandatory( \%Step_map );

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ROUTINES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

sub add_def_params
{
    # Niels Larsen, April 2013.

    # Adds optional parameters shared by all steps, such as "input-step"
    # and "output-name". Also fills the run-time hash with all values that
    # programs should use. 

    my ( $map,
        ) = @_;

    my ( $name, $step, $run, $doc );

    foreach $name ( keys %{ $map } )
    {
        $step = $map->{ $name };

        $step->{"id"} = undef;
      
        if ( $doc = $Recipe::Docs::Docs_map{ $name } and $doc->{"summary"} )
        {
            $doc->{"summary"} =~ s/\n/ /g;
            $doc->{"summary"} =~ s/  / /g;
            $doc->{"summary"} =~ s/^\s+//;
            $doc->{"summary"} =~ s/\s+$//;

            $step->{"summary"} = { "defval" => $doc->{"summary"} };
        }
        else {
            $step->{"summary"} = undef;
        }

        $step->{"comment"} //= undef;

        $step->{"input-step"} //= {};
        $step->{"output-name"} //= {};
        
        if ( $run = $step->{"run"} )
        {
            $run->{"prl_precmd"} //= undef;
            $run->{"precmd"} //= undef;
            
            $run->{"prl_cmd"} //= undef;
            $run->{"cmd"} //= undef;
            
            $run->{"prl_postcmd"} //= undef;
            $run->{"postcmd"} //= undef;
            
            $run->{"use_recipe"} //= undef;
            $run->{"use_stats"} //= 1;
            $run->{"out_name"} //= undef;
            
            $run->{"sum_routine"} //= undef;
            $run->{"dir_routine"} //= undef;
            
            $run->{"in_zipped"} //= 1;
            $run->{"out_dirs"} //= 0;
            
            if ( exists $run->{"in_multi"} and exists $run->{"out_multi"} ) 
            {
                if ( not defined $step->{"keep-outputs"} ) {
                    $step->{"keep-outputs"} = {};
                }
                
                if ( not defined $step->{"zip-outputs"} ) {
                    $step->{"zip-outputs"} = { "defval" => "yes" };
                }
            }

            bless $run;
        }
    }

    return;
};

sub add_def_values
{
    # Niels Larsen, April 2013.

    # Adds default values to parameters declared in the steps in this module
    # above. Also checks that the parameter names are in Recipe::Params::Param_map.
    # Returns nothing.
    
    my ( $steps,    # Steps hash
        ) = @_;

    # Returns nothing.

    my ( $name, $step, $key, $val, $pmap, @errs, $msg );

    $pmap = \%Recipe::Params::Param_map;

    foreach $name ( keys %{ $steps } )
    {
        $step = $steps->{ $name };

        foreach $key ( keys %{ $step } )
        {
            next if $key eq "run";
            next if $key eq "steps";

            if ( $pmap->{ $key } )
            {
                $step->{ $key } = { %{ $pmap->{ $key } }, %{ $step->{ $key } } };
            }
            else {
                push @errs, ["", qq (Parameter "$key" in step "$name" is not declared) ];
            }
        }
    }

    if ( @errs )
    {
        $msg->{"oops"} = qq (Step parameters not declared in Recipe::Params:);

        $msg->{"list"} = \@errs;
        $msg->{"indent"} = 0;

        $msg->{"help"} = 
            qq (Declare the missing parameter(s) by editing the file\n)
           .qq ($Common::Config::plm_dir/Recipe/Params.pm);

        &Recipe::Messages::oops( $msg );
    }
        
    return;
}

sub check_mandatory
{
    # Niels Larsen, March 2012. 
    
    # Verifies that mandatory steps and keys are present and look right. 
    # Returns nothing.

    my ( $map,         # Step map
        ) = @_;

    # Returns nothing.

    my ( $step, $name, $run, @msgs, $msg );

    # >>>>>>>>>>>>>>>>>>>>>>>>>>>> MISSING FIELDS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    foreach $name ( keys %{ $map } )
    {
        $step = $map->{"name"};
        
        if ( $run = $step->{"run"} )
        {
            if ( $run->{"routine"} )
            {
                if ( not Registry::Check->routine_exists( { "routine" => $run->{"routine"}, "fatal" => 0 } ) )
                {
                    $msg->{"oops"} = qq (Routine does not exist: $run->{"routine"});
                    $msg->{"help"} = qq (The wrong routine is in step "$name"\n);
                    $msg->{"help"} = qq (Please correct this by editing the file\n);
                    $msg->{"help"} .= qq ($Common::Config::plm_dir/Recipe/Steps.pm\n);
                    
                    &Recipe::Messages::oops( $msg );
                }
            }
            else 
            {
                if ( not $run->{"cmd"} and not $run->{"prl_cmd"} ) {
                    push @msgs, qq (Missing run key "cmd" or "prl_cmd" for step "$name");
                }
                
                if ( not defined $run->{"in_multi"} ) {
                    push @msgs, qq (Missing run key "in_multi" for step "$name");
                }
                
                if ( not defined $run->{"out_multi"} ) {
                    push @msgs, qq (Missing run key "out_multi" for step "$name");
                }
                
                if ( not $run->{"out_suffix"} ) {
                    push @msgs, qq (Missing run key "out_suffix" for step "$name");
                }
            }
        }
    }

    if ( @msgs ) 
    {
        $msg->{"oops"} = qq (Mandatory fields missing:);
        $msg->{"list"} = \@msgs;
        $msg->{"help"} = qq (Please correct this by editing the file\n);
        $msg->{"help"} .= qq ($Common::Config::plm_dir/Recipe/Steps.pm\n);
        
        &Recipe::Messages::oops( $msg );
    }
        
    # >>>>>>>>>>>>>>>>>>>>>>>>>>>> WRONG IO KEYS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    foreach $name ( keys %{ $map } )
    {
        $step = $map->{ $name };
        
        if ( $run = $step->{"run"} )
        {
            next if $run->{"routine"};
            
            if ( $run->{"prl_cmd"} and not $run->{"in_multi"} and not $run->{"out_multi"} )
            {
                $msg->{"oops"} = qq (The key "in_multi" and/or "out_multi" missing from the step "$name");
                $msg->{"help"} = qq (Parallel jobs require multiple inputs and outputs.\n);
                $msg->{"help"} .= qq (Please correct this by setting the "in_multi" and\n);
                $msg->{"help"} .= qq ("out_multi" keys in the "$name" dictionary entry in\n);
                $msg->{"help"} .= qq ($Common::Config::plm_dir/Recipe/Steps.pm\n);
                
                &Recipe::Messages::oops( $msg );
            }
        }
    }
    
    return;
}

sub get_step
{
    # Niels Larsen, May 2013.

    # Returns a recipe step with the given name. Version numbers are removed
    # before the lookup. If the step is not found, a fatal error message is 
    # created or if the fatal flag is unset, undef is returned. 

    my ( $name,        # Step name
         $fatal,       # Fatal flag - OPTIONAL, default 1
        ) = @_;

    # Returns a hash, nothing or exits.

    my ( $msg );

    if ( $name )
    {
        $name =~ s/\.\d+$//;

        if ( exists $Step_map{ $name } )
        {
            return $Step_map{ $name };
        }
        else
        {
            $msg->{"oops"} = qq (Un-recognized step "$name");

            $msg->{"help"} = qq (Perhaps this is a recipe editing mistake, or a step name\n);
            $msg->{"help"} .= qq (has changed in a recent software update. List all recognized\n);
            $msg->{"help"} .= qq (step names with 'help_recipe steps' and then edit the recipe.);
            
            &Recipe::Messages::oops( $msg );
        }
    }
    else {
        &error( qq (No recipe step name is given) );
    }

    return wantarray ? %Step_map : \%Step_map;
}

sub get_map
{
    # Niels Larsen, May 2013.

    # Returns a dictionary of allowed recipe fields and values. 

    # Returns a hash.

    return wantarray ? %Step_map : \%Step_map;
}

sub get_step_text
{
    # Niels Larsen, March 2012. 

    # Returns a formatted step text with default values. 

    my ( $name,      # Step name
         $indent,    # Indentation level - OPTIONAL, default 1
        ) = @_;

    # Returns a string.

    my ( $step, $key, $name2, $blanks, $val, $text );

    $indent //= 1;
    $blanks = " " x $indent;

    $step = &Recipe::Steps::get_step( $name );

    $text = "$blanks<$name>\n";

    foreach $key ( keys %{ $step } )
    {
        next if $key eq "run";
        next if $key eq "summary";
        next if $key eq "id";
        
        if ( $key eq "steps" )
        {
            foreach $name2 ( @{ $step->{"steps"} } )
            {
                $text .= &Recipe::Steps::get_step_text( $name2, $indent + 4 );
            }
        }
        else
        {
            $val = $step->{ $key }->{"defval"} // "";
            $text .= "$blanks    $key = $val\n";
        }
    }

    $text .= "$blanks</$name>\n";

    return $text;
}

1;

__END__

        # Forward primers
        # ---------------
        
        # In the primer demultiplex the forward primer is excluded from the 
        # output, so those sequences will not have the forward primer. But the
        # PCR may extend into the the reverse primer near the end of sequence,
        # so we do need to clip and trim remnants of the reverse primer. The 
        # next two steps do that. In the example below, the trimming removes 
        # bases that match just the end of the primer as it slides into the 
        # sequence. The bases marked by '+' will be kept and the predecing 
        # ones discarded,
        #
        #  primer:  CAGCAGCCGCGGTAATAC -->
        #  sequence:          GGTAATACAGGCCTT ............
        #                             +++++++++++++++++++++
        # 
        # In effect sequence-trim "peels away" whatever matches the primer,
        # down to a single base. Some real data may disappear here and there,
        # but that loss is better than to have primer remnants. Besides, if
        # clustering is done, as we do below, then deriving consenses from 
        # cluster-alignments will restablish correct endings.
